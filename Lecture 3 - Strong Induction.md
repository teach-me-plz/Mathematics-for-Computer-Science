
```table-of-contents
```

---
우리는 증명에 대해 공부했다.
그래서 훌륭한 증명이란 무엇인가?

**정확해야 하고 모든 주요 사항과 단계가 완전해야 하며 이해하기 쉽도록 명확해야 한다.**   
**거기에 더해 간략하고, 우아하고, 정리가 순서대로 잘 되어 있어야 한다.**

어떤 곳에서는 증명을 거꾸로 해보라고 가르치기도 한다.
사람들을 혼란스럽게 하고 싶은 게 아니라면 증명은 모두 공리로부터 출발하는 것이 좋다.

## 왜 이렇게 증명에 목을 매는가?

Airbus A300은 소프트웨어로 완전히 운영되는 최초의 상업용 제트기 중 하나다.
이륙, 비행, 착륙을 오직 소프트웨어로만 동작하며 첫 시범 비행에서 착륙 직전에 비행기 문을 여는 바람에 사고가 발생했다.   

Therac-25라는 암 환자를 위한 방사선 치료 장비는 때때로 race condition에 빠지게 되어 환자에게 방사선을 퍼붓는 일이 있었다.   

2000년 선거에서 앨 고어와 조지 부시의 대선에서는 앨 고어가 플로리다의 투표소에서 -16000개의 표를 받는 경우도 있었다.      

정말 무서운 점은 20년, 30년 후 우리의, 누군가의 삶이 여러분 중 일부가 작성한 소프트웨어에 달려 있을 가능성이 있다.   
옆 사람을 보라!      

우리는 확실한 증명을 해야 하는 이유를 얻었다.      
실제로 출판된 모든 증명의 3분의 1은 버그나 결함이 있어서 증명이 명확하지 않다.      


## 불변량 (invariant)

어떤 유형의 변형이 객체에 적용될 때, 변경되지 않고 보존되는 수학적 객체의 클래스에 의해서 계속 유지되는 속성.      
예를 들자면 평면의 삼각형의 영역에서 내각의 합은 180° 인 불변량을 가진다.      
컴퓨터 과학에서 매우 강력하고 일반적으로 사용되는 개념으로, 귀납과 매우 밀접하게 연관되어 있다.      
시스템의 상태가 결코 특정한 특수 상태에 들어갈 수 가 없다는 것을 보여주기 위해서 초기 상태에서 유지되고 모든 합법적인 움직임(legal move)에 의해 보존되며, 그 특수 상태에서는 존재하지 않는 불변성이라는 속성이 있다는 것을 보여주면 충분하다.      

만약, 이 불변성이라는 속성을 가지고 처음부터 끝까지, 즉 모든 단계에서 유지된다면 도달할 수 있는 유일한 상태는 이 불변성을 가지고 있어야 한다는 것이다.

시스템이나 알고리즘을 분석할 때 항상 중요한 것은 무엇이 핵심 속성이고 불변성을 띄는가 이다.      

알고리즘을 좀 풀어봤다면 누구나 마주했을 알파벳 퍼즐에 관해 이야기 해보자.   

## 문제

간단하게 빈 공간으로 글자를 움직여 순서를 맞추는 퍼즐을 생각해보자.      

|   A   |   B   |   C   |     | A     | B     | C     |
| :---: | :---: | :---: | --- | ----- | ----- | ----- |
| **D** | **E** | **F** | →   | **D** | **E** | **F** |
| **H** | **G** |       |     | **G** | **H** |       |

왼쪽의 글자 배열을 오른쪽으로 바꿔보자!   
(이와 관련된 알고리즘 문제를 풀어본 사람이라면 누구나 답을 알 것이다!)    

### 정리

- **Legal move:** 글자를 빈 공간으로 옮겨서 순서를 맞춘다.   
- **Theory:**  G와 H의 위치만 뒤바꾸고 나머지 글자들은 원래 자리로 되돌리는 일련의 유효한 이동은 존재하지 않는다.    

### Lemma 1
행 이동은 알파벳의 상대적인 순서를 변화시키지 않는다.

- **Proof 1:** 행 이동에서 i 셀에 있던 항목 하나만 인접한 셀 i - 1 또는 i + 1로 옮기고 나머지 항목은 이동시키지 않는다.   
  따라서 항목들의 상대적 순서는 보존된다.    

여기서 순서란?   

|   1   |   2   |   3   |
| :---: | :---: | :---: |
| **4** | **5** | **6** |
| **7** | **8** |   9   |
를 의미한다.   

|   A   |   B   |   C   |     | A     | B     | C     |
| :---: | :---: | :---: | --- | ----- | ----- | ----- |
| **D** | **E** |       | →   | **D** |       | **E** |
| **H** | **G** | **F** |     | **G** | **H** | **F** |

E 가 행 이동을 했을 시의 상대적인 순서 변화는   

|   1   |   2   |   3   |     | 1     | 2     | 3     |
| :---: | :---: | :---: | --- | ----- | ----- | ----- |
| **4** | **5** |       | →   | **4** |       | **5** |
| **6** | **7** | **8** |     | **6** | **7** | **8** |
이렇게 바뀌게 되며 그 어떤 알파벳도 순서가 바뀌지 않는다.   

이에 따른 증명은 다음과 같다.   



### Lemma 2
열 이동은 정확히 두 쌍의 알파벳에 대해서만 상대적 순서를 뒤바꾼다.    

- **Proof 2:** 열 이동시 `i` 번 칸에 있던 항목을 빈 칸인 `i - 3` 또는 `i + 3` 으로 옮기며, 한 항목이 3칸 만큼 이동하면, 그 항목은 `i - 1`, `i - 2` 또는 `i + 1`, `i + 2` 에 있던 두 항목과 상대적인 순서를 바꾸게 된다.   

|   A   |   B   |   C   |     | A     | B     | C     |
| :---: | :---: | :---: | --- | ----- | ----- | ----- |
| **D** | **F** |       | →   | **D** | **F** | **G** |
| **H** | **E** | **G** |     | **G** | **E** |       |

|   1   |   2   |   3   |     | 1     | 2     | 3     |
| :---: | :---: | :---: | --- | ----- | ----- | ----- |
| **4** | **5** |       | →   | **4** | **5** | **6** |
| **6** | **7** | **8** |     | **7** | **8** |       |
G는 앞의 알파벳 H, E의 상대적 순서를 바꾸게 된다.   


자, 다음 정리를 하기전에 앞서, 한가지를 정의하고 가자.   
### Define
역전 쌍 (inverted pair) 이란?   
알파벳 순서 상 `pair.first` 가 `pair.second` 보다 앞에 위치하나 퍼즐 배치 상에서는 `pair.first`가 `pair.second` 보다 뒤에 있는 경우를 말한다.   

### Lemma 3
알파벳이 움직이는 동안 3가지 상태변화가 일어난다.   
열 이동시에 2개의 반전이 증가하거나 2개의 반전이 감소 하거나 그대로 유지가 된다.   

- **Proof 3:** 
  - 행 이동시 아무런 상태변화가 없다. [Lemma 1](#lemma-1)   
  - 열 이동시 2개의 쌍의 순서가 달라진다. [Lemma 2](#lemma-2)   

위의 증명을 토대로 열 이동 사례 A, B, C 를 들어보자면
A. 두 쌍이 순서대로 서있다 → 역전 쌍이 2개가 생긴다.     
B. 두 쌍이 역순으로 서있다 → 역전 쌍이 2개가 사라진다.    
C. 두 쌍이 하나는 순서대로 하나는 역순으로 서있다 → 역전 쌍의 개수는 변하지 않는다.    

### Corollary 1 (따름 정리, 그 명제나 정리에서 바로 유도되는 명제)

따라서, 역전 쌍의 개수는 짝수 단위로 증감 하며 짝 / 홀 여부는 변화하지 않는것을 의미한다.   

### Lemma 4

|   A   |   B   |   C   |
| :---: | :---: | :---: |
| **D** | **E** | **F** |
| **H** | **G** |       |
위 퍼즐은 현재 역전 쌍을 홀수 개 가지고 있으므로 현재 상태에서 도달할 수 있는 역전 쌍의 개수는 항상 홀수 이다.   

이를 통해 얻을 수 있는 귀납적 가설은 **P(n)에서의 n번의 이동 순서가 끝나면 역전 쌍의 개수는 홀수 이다.** 가 된다.   

### Induction   

- 기초   
  n = 0 인 경우 역전 쌍의 개수는 홀수이다. == true      

- 귀납   
  Corollary 1에 따라 역전 쌍의 개수는 홀수라는 것을 의미한다.   
  
- 결론   
  이 퍼즐은 풀 수 없다!   

### Invariant
|   A   |   B   |   C   |
| :---: | :---: | :---: |
| **D** | **E** | **F** |
| **H** | **G** |       |

**이 퍼즐에서의 역전 쌍의 개수는 항상 홀수이다.**   


## 강한 귀납법

강한 귀납법 또한 일반 귀납법처럼 공리로 표현할 수 있다.

강한 귀납법(Strong Induction)의 형식적 명제는 다음과 같다

**강한 귀납법(Strong Induction) 원리**  
임의의 술어 $P(n)$에 대하여,
1. **기저 단계(Base Case):** $P(0)$이 참이고,        
2. **귀납 단계(Inductive Step):** 임의의 $n≥0$에 대하여 $$(P(0)∧P(1)∧⋯∧P(n))  ⟹  P(n+1))$$
라면, $$∀n≥0,  P(n)$$이 성립한다.   

즉 일반 귀납법이 $P(n)  ⟹  P(n+1)$ 하나만 가정하는 데 비해,  
강한 귀납법은 $P(0),P(1),…,P(n)$ 전부를 가정하고 $P(n+1)$을 유도할 수 있다는 점이 다르다.