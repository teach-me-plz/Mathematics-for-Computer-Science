## 목차
- [정수론](#정수론)
  - [The Greatest Common Divisor (GDB)](#the-greatest-common-divisor-gdb)
    - [성질](#성질)
  - [Euclid's Algorithm](#euclids-algorithm)
  - [The Pulverizer](#the-pulverizer)
    - [Euclid's algorithm solve](#euclids-algorithm-solve)
    - [Pulverizer solve](#pulverizer-solve)
  - [Modular Arithmetic](#modular-arithmetic)
    - [합동의 관점](#합동의-관점)
  - [Arithmetic with a Prime Modulus](#arithmetic-with-a-prime-modulus)
    - [곱셈 역원](#곱셈-역원)
    - [Cancellation (약분)](#cancellation-약분)
    - [순열](#순열)
  - [Fermat's Little Theorem](#fermats-little-theorem)
    - [페르마의 소정리 정리](#페르마의-소정리-정리)
    - [페르마의 소정리 증명](#페르마의-소정리-증명)
  - [Relative Primality](#relative-primality)
    - [순열 성질](#순열-성질)
    - [Euler's Theorem](#eulers-theorem)
      - [오일러 피 함수](#오일러-피-함수)
        - [오일러 피 정리](#오일러-피-정리)
        - [오일러 피 증명](#오일러-피-증명)
      - [오일러 정리](#오일러-정리)
      - [오일러 정리 증명](#오일러-정리-증명)
  - [RSA 암호 시스템](#rsa-암호-시스템)
    - [단계](#단계)
    - [예시](#예시)
      - [사전 준비](#사전-준비)
      - [개인키 공개키 완성](#개인키-공개키-완성)
      - ["Hello, world!" 암호화 \& 복호화](#hello-world-암호화--복호화)
  - [강의를 마무리 하며...](#강의를-마무리-하며)

---

# 정수론

정수론은 정수를 연구하는 학문이다.   

정수론 또는 수론이라고 불리우는 정수론은 실제 일상생활에 쓰이는 경우가 별로 없었지만 컴퓨터가 발전하면서 암호학에서 이 정수론을 기본으로하며 컴퓨터 공학에서 많이 사용하게 된다.   

앞으로 나오는 수들을 정수 라고 기본 전제로 깔고 가도록 하겠다!

$$
\Z \space 를 \space 알아보자!
$$

---

## The Greatest Common Divisor (GDB)   

**최대공약수**

각 정수 $a$, $b$를 나누는 가장 큰 양의 정수이다.   

$\gcd(a, b) = d$ 에서 $d$는 $d\mid a$, $d\mid b$를 만족하는 가장 큰 정수이다.   

$\gcd(a, b)$ 라고 표현할 수 있다.   

최대 공약수에는 다음과 같은 성질을 가지고 있다.   

---

### 성질

1. $a$, $b$의 모든 공약수는 $\gcd(a, b)$를 나눈다.   
2. $k > 0$ 일때, $\gcd(ka, kb) = k \cdot gcd(a, b)$ 가 성립한다.   
3. $\gcd(a, b) = 1$ 이고 $\gcd(a, c) = 1$ 이면  $\gcd(a, bc) = 1$ 이다.   
4. $a\mid bc$ 이고 $\gcd(a, b) = 1$ 이면 $a\mid c$ 이다.   
5. $\gcd(a, b) = \gcd(b, rem(a, b))$ 가 성립한다.   

---

## Euclid's Algorithm

위의 5번 성질을 이용하여 두 정수의 최대공약수를 빠르고 간단하게 구하기 위해 고안된 유클리드 알고리즘에 대해 알아보자!   

간단하게 예시를 통해 어떻게 계산이 이루어지는지 보자.   

두 정수 $1147$, $899$ 의 최대 공약수를 구해보겠다.   

![유클리드 알고리즘즘](../images/유클리드알고리즘.png)   

---

## The Pulverizer

**분해기**

라고도 불리우는 이 방식은 오늘날에 있어 "**확장 유클리드 알고리즘**"으로 더 잘 알려져 있다.   

확장 유클리드 알고리즘은 베주 항등식(Bézout’s identity)을 이용하여$\gcd(a,b)$를 두 정수 $a$, $b$의 정수 선형 결합으로 표현하는 방법을 실제 계산 과정에 포함시킨 알고리즘이다.   

이해를 돕기 위해 유클리드 알고리즘과 확장 유클리드 알고리즘 이 두가지 버전으로 정수 $259$, $70$의 최대공약수 찾기를 진행해 보겠다.   

---

### Euclid's algorithm solve

$\gcd(259, 70) = \gcd(70, rem(259, 70))$   
$\qquad\qquad\qquad= \gcd(49, rem(70, 49))$   
$\qquad\qquad\qquad= \gcd(21, rem(49, 21))$   
$\qquad\qquad\qquad= \gcd(7, rem(21, 7))$   
$\qquad\qquad\qquad= 7$   

### Pulverizer solve

|$x$|$y$|$rem(x,y) = x - q \cdot y$|
|---|---|--------------------------|
|$259$|$70$|$49 = 259 - 3 \cdot 70$|
|$70$|$49$|$21 = 70 - 1 \cdot 49$|
|||$\quad = 70 - 1 \cdot ( 259 - 3 \cdot 70)$|
|||$\quad = -1 \cdot 259 + 4 \cdot 70$|
|$49$|$21$|$7 = 49 - 2 \cdot 21$|
|||$\quad = (259 - 3 \cdot 70) - 2 \cdot (-1 \cdot 259 + 4 \cdot 70)$|
|||$\quad = 3 \cdot 259 - 11 \cdot 70$|

---

$\gcd(a, b)$를 구하면서 각 나머지를 $a$와 $b$의 선형 결합으로 표현하는 방법을 기록하는 방식으로 계산한다.   
이것이 가치가 있는 이유는 우리의 목표는 최대공약수를 선형 결합으로 표현하는 것이기 때문이다.   

이 분해기 알고리즘은 항상 작동하고 종료된다는 것을 수학적 귀납법으로 증명할 수 있으며 매우 큰 수들도 빠르게 `분해`할 수 있게 된다.   
그리고 이 빠른 분해 속도는 `RSA 공개키` 시스템에서 역원을 구할 때 필수적인 도구가 된다.   

---

## Modular Arithmetic

$n \mid a - b$일때 $a$와 $b$가 법(modulus) $n$에 대해 합동이다.   

$$a \equiv b \pmod{n} \iff rem(a,n) = rem(b,n)$$   

이는 다른 표현식으로도 표현될 수 있다.   

$$a \equiv rem(a, n)\pmod{n}$$

---

### 합동의 관점

이 합동을 바라보는 또다른 관점으로는 정수 전체를 $n$개의 부분 집합으로 보는 것이다.   

간단하게 $a \equiv rem(a,3) \pmod{3}$에서의 정수 집합들은 다음과 같이 나눌 수 있다.   

$$\cdots, -6, -3, 0, 3, 6, \cdots \rArr rem(a,3) = 0$$
$$\cdots, -5, -2, 1, 4, 7, \cdots \rArr rem(a,3) = 1$$
$$\cdots, -4, -1, 2, 5, 8, \cdots \rArr rem(a,3) = 2$$

<details>

<summary>합동의 성질</summary>

1. $a \equiv a \pmod{n}$   
    자기 자신과는 항상 합동이다.   
2. $a \equiv b \pmod{n}$ 이면 $b \equiv a \pmod{n}$   
    반대도 합동이다.   
3. $a \equiv b \pmod{n}$ 이고 $b \equiv c \pmod{n}$이면 $a \equiv c \pmod{n}$ 이다.   
    추이적이다.   
4. $a \equiv b \pmod{n}$이면 $a + c \equiv b + c \pmod{n}$도 합동이다.   
    더하기가 가능하다.   
5. $a \equiv b \pmod{n}$이면 $ac \equiv bc \pmod{n}$도 합동이다.   
    곱하기가 가능하다.   
6. $a \equiv b \pmod{n}$ 이고 $c \equiv d \pmod{n}$ 이면 $ac \equiv bd \pmod{n}$도 합동이다.   
    더하기 + 추이적이다.   
7. $a \equiv b \pmod{n}$ 이고 $c \equiv d \pmod{n}$ 이면 $ac \equiv bd \pmod{n}$도 합동이다.   
    곱하기 + 추이적이다.   

</details>

## Arithmetic with a Prime Modulus

이제 법(Modulus)를 소수로 하는 연산에 대해 알아보자.   

**이게 왜 필요한가?**
뒤에 있을 RSA는 $n = pq$로 합성수 이기에 복호화 시에 생기는 나눗셈의 결과가 정수가 나오지 않을 수 있다.   
그렇기에 소수 $p, q$의 역원 성질을 이용하는 것이다.   
지금은 이해가 잘 안될 것이다.   
뒤에 마저 설명할테니 일단 머릿속에 넣어두고 이어 가도록 하겠다.   

---

### 곱셈 역원

$x^{-1}$처럼 표기되는 곱셈 역원은 $x \cdot x^{-1}$의 결과가 항상 $1$이 되도록 해준다.   
일반적으로 실수 영역에서는 $0$을 제외한 모든 수에 대해 곱셈 역원이 존재하나, 정수 집합 내에서는 일반적으로 역원이 존재하지 않는다.   

그런데 모듈러 연산에서는 법이 소수일때 역원이 거의 대부분 존재한다.   
($k \equiv 1 \pmod{p}$ 에서 k가 p의 배수인 경우를 제외)   

그리고 모듈러 연산에서의 역원은 항상 $x \cdot x^{-1} \equiv 1 \pmod{p}$의 형태를 갖춘다.   

---

### Cancellation (약분)

**분모와 분자 혹은 양변의 수를 공약수로 나누어 크기를 줄이는 것.**   

모듈러 산술에서 **약분**이 성립하려면 **약분하려는 수와 법(modulus)이 서로소**여야 한다.   

법이 소수 $p$라면 $p$의 배수가 아닌 모든 수가 $p$와 서로소이므로 항상 곱셈 역원이 존재한다.   
모듈러 연산에서는 양변에 같은 수를 곱하는 것은 가능하지만, 직접 나누는 연산은 정의되지 않는다.   
그러나 곱셈 역원을 곱하면 나눗셈과 동일한 효과를 내므로, 이는 곧 약분과 같다.   

---

### 순열

우리는 위의 모듈러 순열 시스템을 이용해 복호화를 손쉽게 할 수 있다.   
암호화는 $m' = m \cdot k \pmod{p}$로 수행하고 복호화시에 $k$의 역원 $k^{-1}$을 곱함으로서 되돌릴 수 있다.   

이렇게 $k$로 곱하는 연산은 메시지 집합 ${0,1, \cdots, p - 1}$을 서로 다른 위치로 재배열(순열)하므로, $k$를 모르는 상대방이 보기에는 암호문이 무작위로 섞인 것처럼 보여 원문을 유추하기 힘들게 된다.   

---

## Fermat's Little Theorem 
**페르마의 소정리**

**$k$의 역원을 더 빠르고 간단하게** 구할 수 있는 방법.   

본론 부터 말하자면 $k$의 역원은 $k^{p - 2}$가 된다.   

---

### 페르마의 소정리 정리 
소수 $p$가 있고 $p \nmid k$ 면 $k^{p - 1} \equiv 1 \pmod{p}$ 가 된다.   

### 페르마의 소정리 증명

$$(p - 1)! = 1 \cdot 2 \cdots (p - 1)$$   
$$= rem(k, p) \cdot rem(2k, p) \cdots rem((p - 1)k, p)$$   
$$\equiv k \cdot 2k \cdots (p - 1)k \pmod{p}$$   
$$\equiv (p - 1)! \cdot k^{p - 1}\pmod{p}$$   

따라서   
$$(p - 1)! \equiv (p - 1)! \cdot k^{p - 1} \pmod{p}$$    
가 성립하게 되고    

여기서 $1 \cdot 2 \cdots p - 1$들 중 그 어느것도 p를 나눌 수 없으므로 p가 소수, $p \nmid (p - 1)!$ 이 성립하므로 약분이 가능하게 되어 
$$1 \equiv k^{p - 1}\pmod{p}$$   
$$k \cdot k^{p - 2} \equiv 1 \pmod{p}$$   
로 $k^{p - 2}$ 가 $k$의 역원이 된다.   

---

## Relative Primality

**서로소**

RSA는 기존의 암호 방식과는 달리 송신자와 수신자가 사전에 비밀키를 주고받기 위해 직접 만날 필요가 없다.   
송신자는 수신자의 공개키로 암호화하고 수신자는 자신의 비밀키로 메시지를 복호화한다.   
RSA는 튜링의 방식과는 달리 큰 소수를 법으로 하는 대신, 2개의 큰 소수$p,q$의 곱 $n$을 법으로 연산한다.   
따라서 RSA에서의 암호키는 $n$과 서로소가 되어야 역원을 구할 수 있기 때문에 합성수를 법으로 하는 산술과 서로소를 사용하게 된다.   

법이 소수일 때는 0을 제외한 모든 수가 법과 서로소이므로 항상 곱셈 역원이 존재한다.   
하지만 법이 합성수면, 법과 서로소가 아닌 수는 역원이 없기 때문에 연산이 더 복잡해진다.   
반면, 법과 서로소인 수들은 소수 법에서처럼 곱셈 역원이 존재하여 비교적 다루기 쉽다.   

페르마의 소정리는 소수 법에서만 모든 0이 아닌 수에 적용되는데, 법이 합성수가 되면 적용 범위가 줄어든다.   
합성수 법에서 역원을 구하려면 오일러의 정리가 필요하다.   

---

### 순열 성질

법 $n$에 대해 $n$보다 작은 서로소들의 집합을 $\{k_1, k_2, \dots, k_r\}$이라고 해보자.   
만약 $n$과 $k$가 서로소라면 각 $k_i$에 $k$를 곱하고 $n$으로 나눈 나머지를 구하면 다시 서로소 집합의 순열이 된다.   

**e.g.**   
  $n = 10, 서로소 집합 \{1,3,7,9\}, k = 3$
  $$1 \cdot 3 \equiv 3 \pmod{10}$$   
  $$3 \cdot 3 \equiv 3 \pmod{10}$$   
  $$7 \cdot 3 \equiv 3 \pmod{10}$$   
  $$8 \cdot 3 \equiv 3 \pmod{10}$$   
  $$= \{3,9,1,7\}$$

한마디로 정리하면 서로소 집합의 모든 원소를 곱한 값이 변하지 않는다는 것이다.   
  
### Euler's Theorem

**오일러 정리**

하지만 앞서 오일러 피 함수에 대해 알고 가야한다.   

---

#### 오일러 피 함수

**$\phi(n)$ = n**이하의 양의 정수중 $n$과 서로소인 정수의 개수.   

**e.g.**   
  $\phi(7) = 6 (1, 2, 3, 4, 5, 6)$   
  $\phi(12) = 4 (1, 5, 7, 11)$   

오일러 피 함수 계산은 소인수 분해를 통해 쉽게 이루어질 수 있다.   

$$
\phi(n) = n \left( 1 - \frac{1}{p_1} \right) \left( 1 - \frac{1}{p_2} \right) \cdots \left( 1 - \frac{1}{p_j} \right)
$$

**e.g.**

$300 = (2^2 \cdot 3 \cdot 5^2)$   
$\phi(300) = 300 \left( 1 - \frac{1}{2} \right) \left( 1 - \frac{1}{3} \right) \left( 1 - \frac{1}{5} \right)$   
$= 80$   

---

##### 오일러 피 정리

$n = pq$이고 $p,q$가 서로 다른 소수라면
$$
\phi(n) = (p - 1)(q - 1)
$$

##### 오일러 피 증명

$n$ = pq$ 일 때, $n$과 서로소가 아닌 수는 $p$의 배수 또는 $q$의 배수이다.   
$1 ~ pq$ 중에서   
  - p의 배수는 q개   
  - q의 배수는 p개   
  - pq 중복 1개    

따라서 서로소가 아닌 수의 개수는 $p + q - 1$이 된다.   
전체 $pq$개에서 이를 빼면   
$$
\phi(n) = pq - (p + q - 1) = (p - 1)(q - 1)
$$

---

#### 오일러 정리

$n$이 양의 정수이고 k가 n과 서로소라면   
$$
k^{\phi(n)} \equiv 1 \pmod{n}
$$

#### 오일러 정리 증명

- $1 \le k_i < n$이고 $n$과 서로소인 모든 수를 $\{k_1,k_2, \dots, k_r \}$이라 하면 $r = \phi(n)$이 된다.   


- $k$와 모든 $k_i$를 곱한 수의 나머지 집합   
  $\{rem(k_1k, n), rem(k_2k, n), \dots, rem(k_rk, n)\}$
  은 위 서로수의 순열이 된다.   
- 따라서   
  $(k_1 \cdot k)(k_2 \cdot k) \cdots (k_r \cdot k) \equiv k_1k_2 \cdots k_r \pmod{n}$
  이 성립하게 되며
- 이를 정리하면   
  $(k_1k_2 \cdots k_r) \cdot k^r \equiv k_1k_2 \cdots k_r \pmod{n}$ 으로   
- $(k_1k_2 \cdots k_r)$과 $n$이 서로소이므로 양 변에 역원을 곱하게 되면   
- $k^r \equiv 1 \pmod{n}$이 된다.   
- $r = \phi(n)$이므로 

따라서 최종적으로
$$
k^{\phi(n)} \equiv 1 \pmod{n}
$$

이 성립 된다.


## RSA 암호 시스템

### 단계

- **사전준비**   
    수신자가 **공개키**, **개인키**를 다음과 같은 순서로 생성한다.   
    1. 서로다른 소수 $p,q$ 생성   
    (이 때 암호화할 메시지의 수보다는 커야 한다.)   
    2. $n = pq$ 로 정의.   
    3. $\gcd(e, \phi(n)) = 1$을 만족하는 e를 선택한다.   
    4. $d \cdot e \equiv 1 \pmod{\phi(n)}$를 만족하는 d를 구한다.   
    (이는 확장 유클리드로 쉽게 풀 수 있음.)   

- **암호화**   
    1. 메시지가 주어지면 송신자는$\gcd(m,n) = 1$인지 확인 후 공개키를 사용하여 메시지를 암호화 한다.   
$$m' = rem(m^e,n)$$

- **복호화**   
    1. 수신자는 개인키를 사용하여 암호화된 메시지 $m'$를 복호화 하여 기존의 메시지 $m$을 얻는다
$$m = rem((m')^d,n)$$

이에 대한 증명은 따로 하지 않겠다.

---

### 예시

#### 사전 준비

$p = 61, q = 53, n = 3233$   
$\phi(n) = (61 - 1)(53 - 1) = 3120$   
$e = 17, \quad (\gcd(17, 3120) = 1)$   
$d = 2753, \quad d \cdot 17 \equiv 1 \pmod{3120}$   

#### 개인키 공개키 완성

$$공개키: (e, n) = (17, 3233)$$
$$개인키: (d, n) = (2753, 3233)$$

#### "Hello, world!" 암호화 & 복호화

|문자|$m$(ASCII)|암호화 $m'=rem(m^e, n)$|복호화 $m=rem((m')^d, n)$|
|:-:|:--------:|:------------------:|:-------------------:|
| h |   104    |        2170        |         104         |
| e |   101    |        1313        |         101         |
| l |   108    |         745        |         108         |
| l |   108    |         745        |         108         |
| o |   111    |        2185        |         111         |
| , |    44    |         678        |          44         |
|(space)|  32  |        1992        |          32         |
| w |   119    |        1107        |         119         |
| o |   111    |        2185        |         111         |
| r |   114    |        2412        |         114         |
| l |   108    |         745        |         108         |
| d |   100    |        1773        |         100         |
| ! |   33     |        1853        |          33         |

하나만 계산해보자!   

$$m'= rem(104^{17}, 3233) = 2170$$
$$m = rem(2170^{2753}, 3233) = 104$$

---

## 강의를 마무리 하며...

리만 가설도 좀 정리해서 이야기해주고 싶었는데 파도파도 괴담뿐이라 여기까지만 준비했습니다.   

조금만 풀어서 이야기하자면 소수의 분포가 복소평면 위의 일직선상에 모두 일치해 있다는 건데 이게 뭐 양자역학과도 연관이 있다고 합니다.   
평생을 리만가설 풀다가 조현병 앓은 수학자, 먼 미래에 깨어나면 처음으로 할 질문으로 리만가설 풀렸나고 물어본다고 하는 수학자 등등...    
너무 어려워서 더는 파지 않기로했습니다.    

이 문제 풀면 클레이 연구소에서 백만달러 준다는데 이게 인생역전의 기회가 아닐까요?    